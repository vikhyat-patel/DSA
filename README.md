# DSA

Some important questions for software interviews. Check out the following ones also!

1. Search in a matrix - There are 2 variations of this problem, one in GFG - row & col sorted{Two pointer} & other in Leetcode, here we apply some tricks to solve it in O(logN + logM), both questions are very important must look.
2. Number of 1 Bits - {very very interesting, must look}
3. Parenthesis checker - {stack}
4. Sort a stack - {recursion}, Special stack {simple implementation}
5. Queue using 2 stacks & Stack using 2 queues - {Imp ques, see Yt video}
6. Subarray with ZERO sum - {Prefix sum & Hashing, easy}
7. Subarray with given sum - {Sliding Window approach}
8. Kadane's algo & its variations - {Very IMP}
9. Jump Game - {max_reach concept, easy}
10. Maximum product subarray - {2 way KADANE, easy}
11. Minimum number of jumps - {Tricky ques, {max_reach, steps, jumps}} - Must Look this!
12. Majority Element - {moore's voting algorithm}
13. Find duplicates in the array - {a beautiful logic with constant space}
14. Find Kth smallest element in an array - {priority_queue(max heap), must look} - (similar for Kth largest)
15. Peak Element - {a very beautiful concept of 'BS' with edge cases, must look}
16. Minimize the heights - {a very Tricky ques, revise it GFG}
17. Count pairs with given sum - {use of 'Map' to keep the count of freq}
18. Rotate an array by 'd' places - {use of 3 times reverse function)
19. Minimum Platforms - {sorting arrival & departure, and 2 pointer approach, Must look}
20. Stock Span Problem - {standard stack ques, use of stack<pair>, must look}
21. DP on STOCKS - {very very IMP} - [atmost k transactions,, cooldown,, transaction fee,, valley peak] - Refer 'Leetcode' MUST DO!
22. Maximum of all subarrays of size k - {'Sliding window' technique, very very IMP & Tricky, must look, Gfg}
23. Spirally traversing a matrix - {very tricky Implementation, frequently asked, must revise this, Gfg} - (Top = 0, bottom = r - 1, left = 0, right = c - 1)
24. Remove duplicate elements from sorted Array - {In place, 'TWO Pointer technique'}
25. Intersection/ Union of arrays - {Hashing, unordered_set}
26. (IMP) House Robber (I & II) Questions - {standard 'DP' problems, must look Leetcode}
27. 'Count Inversions' & Print Kth smallest/largest, find kth smallest/largest - {Priority_queue(max/min Heap), look above Github file}
28. House Robber, Jump Game & Pascals Triangle - {IMP Ques, refer Leetcode, must do}
29. 'The Celebrity Problem' - {Two pointer approach, a = 0, b = n - 1, checking the candidate of celebrity}
30. Max Sum without Adjacents - {A very very tricky Ques, use of variables-[val 1 = arr[0], val 2 = max(arr[0], arr[1])] to find the max_sum, corner cases, must look}
31. Sliding Window 'subarray questions' - {subarray with given sum, smallest subarray with sum > X, count subarrays having product < k(IMP) } - Mostly questions follow the similar pattern, revise them they are frequently asked.
32. {Smallest positive missing number(CI/swap), Missing & Repeating(IMP) - Mathematical soln,2eqns..(optimal), Next Permutation (very very imp)} - look out these problems.
33. search element in rotated sorted array(I & II), Min element in rotated sorted array - {std. Binary Search problems - identifying the sorted halves & eliminating them} - must look all the variations.
34. Activity selection problem - {Greedy approach, vector<pair>, sorting wrt endTime}, Job sequencing - {Tough, greedy is easy O(N^2) & O(N), but optimal is O(NlogN) & O(N)}
35. Square root of a number & Nth root of a number - {Typical std. Binary Search problems, eliminating the halves, logN}
36. Koko Eating Bananas, Minimum Number of Days to Make m Bouquets, Smallest Divisor Given a Threshold - {All are std. 'BS' Problems, which work on eliminating the halves and searching the answer in a defined search space which we have to identify}
37. ALL std. 'BINARY SEARCH' ques (very IMP), revise it from 'Striver's Sheet' BS problems..You'll get the concept.
38. {Overlapping Intervals, Police & Thief, Huffman Encoding} - They are std. Greedy problems and they are important also. Must revise them, refer gfg for the same.
39. To find Pow(x,n) - {we can do linear but optimal is Binary Exponentiation - Log(N), similar question is 'count good numbers' on leetcode where we have applied the same logic}
40. Sieve of Eratosthenes - {creating Blackbox (bool type globally)} - IMP CONCEPT {to check how many prime numbers are upto 'n' in O(n) complexity, also we can figure out if the given number is prime or not}


